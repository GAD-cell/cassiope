\section{Related Work}
\paragraph{Graph isomorphism and colour refinement.} 
The graph isomorphism problem concerns whether two graphs are identical topologically, e.g. for two graphs $G$ and $H$, whether there is a bijection $f:V_G \rightarrow V_H$ such that any two vertices $u$ and $v$ are adjacent in $G$ if and only if $f(u)$ and $f(v)$ are adjacent in $H$. If such a bijection exists, we say $G$ and $H$ are \emph{isomorphic} ($G\simeq H$).

Let $C$ be a set of colours. A \emph{vertex colouring refinement} function $\lambda: V \rightarrow C$ assigns each vertex $v\in V$ with a colour $\lambda(v)\in C$. This assignment is performed iteratively until the vertex colours no longer change. Colour refinement can be used to test graph isomorphism by comparing the multisets of vertex colours $\{\!\!\{\lambda(v): v\in V_G\}\!\!\}$ and $\{\!\!\{\lambda(u): u\in V_H\}\!\!\}$, given that $\lambda(\cdot)$ is invariant under isomorphic permutations. A classic example of such tests is the \emph{Weisfeiler-Lehman (WL) test} ~\citep{weisfeiler1968reduction}, which assigns a colour to a vertex based on the colours of its neighbours.
\citet{cai1992optimal} extends 1-WL to compute a colour on each k-tuple of vertices; this extension is known as the \emph{k-dimensional Folklore Weisfeiler-Lehman algorithms} (k-FWL).
We may apply a colouring refinement to all vertices in $G$ iteratively until vertex colours are stabilised. 

Let $(G,\lambda^i)$ denote a colouring on vertices of $G$ after applying a colour refinement function $i$ times, i.e., after the $i$-th iteration, and $P(\lambda^i)$ a partition of the vertex set induced by the colouring $(G,\lambda^i)$. For two vertex partitions $P(\lambda^i)$ and $P(\lambda^j)$ on $G$, if every element
of $P(\lambda^i)$ is a (not necessarily proper) subset of an element of $P(\lambda^j)$, we say $P(\lambda^i)$ \emph{refines} $P(\lambda^j)$. 
When $P(\lambda^{j})\equiv P(\lambda^{j+1})$, we call $\lambda^j$ a \emph{stable colouring} and $P(\lambda^{j})$ a \emph{stable partition} of $G$.


\paragraph{GNNs beyond 1-WL.}
MPNN is a widely adopted graph representation learning approach in many applications. However, there are a few caveats. Firstly, as shown by \citet{xu2018powerful}, the expressive power of MPNN is upper-bounded by 1-WL, which is known to have limited power in distinguishing isomorphic graphs. Secondly, to increase the receptive field, MPNN needs to be stacked deeply, which causes over-smoothing~\citep{zhao2019pairnorm,chen2020measuring} and over-squashing~\citep{topping22oversquashing} that degrade performance. Recent research aims to design more powerful GNNs by incorporating higher-order neighbourhoods~\citep{maron2019provably,morris2019weisfeiler}. However, these methods incur high computational costs and thus are not feasible for large datasets. Other methods alter the MPNN framework or introduce extra heuristics to improve expressivity~\citep{bouritsas2022improving,bodnar2021weisfeiler,bodnar2021weisfeilercellular,bevilacqua2021equivariant,wijesinghe2021new}. However, while these methods are shown to be more powerful than 1-WL, it is still unclear what additional properties they can capture beyond 1-WL. 


\paragraph{GNNs in learning graph algorithms.}
\citet{Velickovic_neuralexecutoin} show that MPNN can imitate classical graph algorithms to learn shortest paths (Bellman-Ford algorithm) and minimum spanning trees (Primâ€™s algorithm). 
\citet{dobrik_neuralbipartite} show that MPNNs can execute the more complex Ford-Fulkerson algorithm, which consists of several composable subroutines, for finding maximum flow. 
\citet{loukas2020graph} further shows that certain GNN can solve graph problems like cycle detection and minimum cut, but only when its depth and width reach a certain level.
\citet{xu20_gnnreasoning} show that the ability of MPNN to imitate complex graph algorithms is restrained by the alignment between its computation structure and the algorithmic structure of the relevant reasoning process. 
One such example, as shown by \citet{anonymous2023rethinking}, is that MPNN cannot solve the biconnectivity problem, despite that this problem has an efficient algorithmic solution linear to graph size. 